import {
  template,
  forEach,
  assign,
  intersection,
  mapKeys,
  keys
} from 'lodash';
import * as path from 'path';
import * as fs from 'fs';
import { execSync, ExecSyncOptions } from 'child_process';
import { sync as commandExists } from 'command-exists';
import chalk from 'chalk';
import * as walk from 'walk-sync';
import * as mkdirp from 'mkdirp';
import * as rimraf from 'rimraf';
import * as yargs from 'yargs';
import * as NestedError from 'nested-error-stacks';
import { sync as isDirectory } from 'is-directory';
import ui from './ui';
import findAddons from './find-addons';
import Command from './command';
import * as createDebug from 'debug';

const debug = createDebug('denali-cli:blueprint');
// tslint:disable-next-line:completed-docs
function run(cmd: string, options: ExecSyncOptions = {}) {
  return execSync(cmd, Object.assign({ stdio: 'pipe' }, options));
}

/**
 * The Blueprint class manages generating code from a template, or "blueprint". Blueprints have
 * three main parts:
 *
 * - The `locals()` hook, used to generate data to fill in the the templates
 *
 * - Templates, found under `<blueprint dir>/files`. These files are copied over into the project.
 *   The can contain ERB style interpolation to inject values from the `locals` data. Filenames can
 *   also contain variables, delimited by `__variable__`
 *
 * - The `postInstall()` hook, which runs after the copying operation is finished. This gives the
 *   blueprint a chance to perform additional steps that simple templating can't support (i.e.
 *   install an node module).
 *
 * The code generated by a blueprint can also be removed via the `destroy` command. That command
 * will only remove files that exactly match the what the blueprint generates, so if you modify a
 * file after it was generated, it won't be removed.
 *
 * @module denali-cli
 */
export default class Blueprint extends Command {

  /**
   * The name used to invoke this blueprint.
   */
  public static blueprintName: string;

  /**
   * The source directory for this blueprints
   */
  public static dir: string;

  /**
   * Files that should be renamed in all blueprints
   * Can be overriden/extended by individual addons
   */
  public static renamedFiles: any = {
      gitignore: '.gitignore',
      package: 'package.json'
  };

  /**
   * Convenience method for calling `.findBlueprints()` and then `.configureBlueprints()`
   */
  public static findAndConfigureBlueprints(yargs: yargs.Argv, action: 'generate' | 'destroy', projectPkg: any) {
    let blueprints = this.findBlueprints(projectPkg);
    return this.configureBlueprints(blueprints, yargs, action, projectPkg);
  }

  /**
   * Find all available blueprints
   */
  public static findBlueprints(projectPkg: any) {
    let blueprints: { [name: string]: typeof Blueprint } = {};
    // Special case denali itself, so it can access it's globally linked blueprints.
    let addons = findAddons(projectPkg && projectPkg.name !== 'denali');
    debug(`discovering available blueprints from [ ${ addons.map((a) => a.pkg.name).join(', ') } ] addons`);
    addons.forEach((addon) => {
      this.discoverBlueprintsForAddon(blueprints, addon.pkg.name, path.join(addon.distDir, 'blueprints'));
    });
    return blueprints;
  }

  /**
   * Given a set of blueprints and a yargs instance, given each blueprint the chance to add a
   * command to the yargs instance for itself
   */
  public static configureBlueprints(blueprints: { [name: string]: typeof Blueprint }, yargs: yargs.Argv, action: 'generate' | 'destroy', projectPkg: any) {
    // Configure a yargs instance with a command for each one
    forEach(blueprints, (BlueprintClass: typeof Blueprint, name: string): void => {
      try {
        debug(`configuring ${ BlueprintClass.blueprintName } blueprint (invocation: "${ name }")`);
        yargs = BlueprintClass.configure(name, yargs, projectPkg, action);
      } catch (error) {
        ui.warn(`${ name } blueprint failed to configure itself:`);
        ui.warn(error.stack);
      }
    });
    return yargs;
  }

  /**
   * Given an addon's name and source directory, load all the blueprints that addon may supply
   */
  public static discoverBlueprintsForAddon(blueprintsSoFar: { [blueprintName: string]: typeof Blueprint }, addonName: string, dir: string) {
    debug(`looking for blueprints in ${ dir }`);
    if (!fs.existsSync(dir)) {
      debug(`${ dir } does not exist, skipping ...`);
      return {};
    }
    // Load the blueprints
    let Blueprints = fs.readdirSync(dir)
      .filter((dirname) => isDirectory(path.join(dir, dirname)))
      .reduce<{ [key: string]: typeof Blueprint }>((BlueprintsSoFar, dirname: string) => {
        let BlueprintClass;
        try {
          BlueprintClass = require(path.join(dir, dirname));
        } catch (e) {
          throw new NestedError(`Unable to load blueprint from ${ dir } -> ${ dirname }`, e);
        }
        BlueprintClass.addon = addonName;
        BlueprintsSoFar[dirname] = BlueprintClass.default || BlueprintClass;
        return BlueprintsSoFar;
      }, {});
    // Capture the source directory of the blueprint
    forEach(Blueprints, (BlueprintClass, blueprintDir) => {
      BlueprintClass.dir = path.join(dir, blueprintDir);
    });
    // Then use the blueprintName as the invocation name, if provided (otherwise, fallback to the
    // directory name
    Blueprints = mapKeys(Blueprints, (BlueprintClass, blueprintDir) => BlueprintClass.blueprintName || blueprintDir);
    debug(`found ${ keys(Blueprints).length } blueprints for ${ addonName }: [ ${ keys(Blueprints).join (', ') } ]`);
    // Move any already-loaded blueprints with the same name as these new ones under an addon-scoped
    // namespace
    intersection(keys(Blueprints), keys(blueprintsSoFar)).forEach((collidingBlueprintName: string) => {
      let clobberedBlueprint = blueprintsSoFar[collidingBlueprintName];
      blueprintsSoFar[clobberedBlueprint.addon + ':' + collidingBlueprintName] = clobberedBlueprint;
    });
    // Also create a map with the blueprint names scoped to the addon name
    return assign(blueprintsSoFar, Blueprints);
  }

  /**
   * Customize the subcommands header to indicate that it's a list of blueprints
   */
  public static configure(blueprintName: string, yargs: yargs.Argv, projectPkg: any, action: 'generate' | 'destroy'): yargs.Argv {
    return super.configure(blueprintName, yargs, projectPkg, { action })
      .updateStrings({
        'Commands:': 'Available Blueprints:'
      });
  }

  /**
   * Should we generate or destroy this blueprint?
   */
  public action: 'generate' | 'destroy';

  /**
   * Immediately delegates to either generate or destroy
   */
  public async run(argv: any) {
    if (argv.action === 'generate') {
      await this.generate(argv);
    } else {
      await this.destroy(argv);
    }
  }

  /**
   * Generate the blueprint. Generates the data to interpolate into the templates, then copies the
   * template files over into the project. Finally, runs the postInstall hook.
   */
  public async generate(argv: any): Promise<void> {
    let data = this.locals(argv);
    let dest = process.cwd();
    let renamedFiles = (<typeof Blueprint>this.constructor).renamedFiles;

    walk(this.templateFiles).forEach((relativepath: string): void => {
      let absolutepath = path.resolve(path.join(this.templateFiles, relativepath));
      if (isDirectory(absolutepath)) {
        return null;
      }

      let filenameTemplate = template(relativepath, {
        interpolate: /__(.+?)__/g,
        sourceURL: relativepath
      });
      let destRelativepath = filenameTemplate(data);
      let basename = path.basename(destRelativepath);

      if (renamedFiles[basename]) {
          destRelativepath = path.join(path.dirname(destRelativepath), renamedFiles[basename]);
      }

      let destAbsolutepath = path.join(dest, destRelativepath);

      if (fs.existsSync(destAbsolutepath)) {
        ui.info(`${ chalk.green('already exists') } ${ destRelativepath }`);
        return;
      }

      let contents = fs.readFileSync(absolutepath, 'utf-8');
      let contentsTemplate = template(contents, {
        interpolate: /<%=([\s\S]+?)%>/g,
        sourceURL: relativepath
      });
      mkdirp.sync(path.dirname(destAbsolutepath));
      fs.writeFileSync(destAbsolutepath, contentsTemplate(data));
      ui.info(`${ chalk.green('create') } ${ destRelativepath }`);
    });

    if (!argv.skipPostInstall) {
      try {
        await this.postInstall(argv);
      } catch (e) {
        throw new NestedError(`postInstall hook for ${ (<typeof Blueprint>this.constructor).blueprintName } failed`, e);
      }
    }
  }

  /**
   * Destroy the blueprint. Generates the data to interpolate into the templates, then deletes any
   * unmodified files that were generated by this blueprint. Then runs the postUninstall hook.
   */
  public async destroy(argv: any): Promise<void> {
    let data = this.locals(argv);
    let dest = process.cwd();

    let filesToDelete: string[] = [];
    walk(this.templateFiles).forEach((relativepath: string) => {
      return filesToDelete.push(path.resolve(path.join(this.templateFiles, relativepath)));
    });

    // Get the absolute paths for the template source file and the dest file
    filesToDelete = filesToDelete.map((absolutepath) => {
      let relativepath = path.relative(this.templateFiles, absolutepath);
      let filenameTemplate = template(relativepath, { interpolate: /__([\S]+)__/g });
      let destRelativepath = filenameTemplate(data);
      let destAbsolutepath = path.join(dest, destRelativepath);
      return { destAbsolutepath, destRelativepath, absolutepath };

    // Ensure that the dest file actually exists
    }).filter(({ destAbsolutepath, destRelativepath, absolutepath }) => {
      if (isDirectory(absolutepath)) {
        return false;
      }
      let fileExists = fs.existsSync(destAbsolutepath);
      if (!fileExists) {
        ui.info(`${ chalk.grey('missing') } ${ destRelativepath }`);
      }
      return fileExists;

    // And either hasn't been altered, or the force option is being used, to ensure we don't destroy
    // code
    }).filter(({ destAbsolutepath, absolutepath, destRelativepath }) => {
      let templateSrc = fs.readFileSync(absolutepath, 'utf-8');
      let compiled = template(templateSrc);
      let destFileIsNotDirty = fs.readFileSync(destAbsolutepath, 'utf-8') === compiled(data);

      if (destFileIsNotDirty) {
        ui.info(`${ chalk.red('destroy') } ${ destRelativepath }`);
      } else {
        ui.info(`${ chalk.blue('skipped') } ${ destRelativepath }`);
      }

      return destFileIsNotDirty;
    }).map(({ destAbsolutepath }) => {
      return destAbsolutepath;
    });

    filesToDelete.forEach((file) => {
      rimraf.sync(file);
    });

    if (!argv.skipPostUninstall) {
      try {
        await this.postUninstall(argv);
      } catch (e) {
        throw new NestedError(`postUninstall hook for ${ (<typeof Blueprint>this.constructor).blueprintName } failed`, e);
      }
    }
  }

  /**
   * A hook to generate data to be interpolated into the blueprint's template files.
   */
  public locals(argv: any): any {
    return argv;
  }

  /**
   * Runs after the templating step is complete, letting you make additional modifications (i.e.
   * install a node module).
   */
  public async postInstall(argv: any): Promise<void> { /* noop by default */ }

  /**
   * Runs when `denali destroy` is invoked, after the applicable template files have been removed.
   * You should clean up / reverse any changes made in postInstall(), but only in a way that avoids
   * removing user modifications.
   */
  public async postUninstall(argv: any): Promise<void> { /* noop by default */ }

  /**
   * Returns the path to this blueprints template files directory. Defaults to `files/`.
   */
  public get templateFiles(): string {
    return path.join((<typeof Blueprint>this.constructor).dir, 'files');
  }

  /**
   * Add a package to this project, using yarn or npm as appropriate.
   */
  public installPackage(pkgName: string, dev?: boolean): void {
    debug(`installing ${ pkgName }`);
    if (this.shouldUseYarn()) {
      run(`yarn add ${ dev ? '--dev' : '' } ${ pkgName }`);
    } else {
      run(`npm install ${ dev ? '-D' : '-S' } ${ pkgName }`);
    }
  }

  /**
   * Add multiple packages to this project, using yarn or npm as appropriate.
   */
  public installPackages(pkgNames: string[], dev?: boolean): void {
    debug(`installing ${ pkgNames.join(', ') }`);
    if (this.shouldUseYarn()) {
      pkgNames.forEach((pkgName) => {
        try {
          run(`yarn add ${ dev ? '--dev' : '' } ${ pkgName }`);
        } catch (e) {
          // Yarn fails the entire command if one package doesn't exist, so we run each separately
        }
      });
    } else {
      run(`npm install ${ dev ? '-D' : '-S' } ${ pkgNames.join(' ') }`);
    }
  }

  /**
   * Remove a package from this project, using yarn or npm as appropriate.
   */
  public uninstallPackage(pkgName: string): void {
    debug(`uninstalling ${ pkgName }`);
    if (this.shouldUseYarn()) {
      run(`yarn remove ${ pkgName }`);
    } else {
      run(`npm uninstall -S ${ pkgName }`);
    }
  }

  /**
   * Remove multiple packages from this project, using yarn or npm as appropriate.
   */
  public uninstallPackages(pkgNames: string[]): void {
    debug(`uninstalling ${ pkgNames.join(', ') }`);
    if (this.shouldUseYarn()) {
      pkgNames.forEach((pkgName) => {
        try {
          run(`yarn remove ${ pkgName }`);
        } catch (e) {
          // Yarn fails the entire command if one package doesn't exist, so we run each separately
        }
      });
    } else {
      run(`npm uninstall -S ${ pkgNames.join(' ') }`);
    }
  }

  /**
   * Check to see whether this project is using yarn for package management
   */
  public shouldUseYarn() {
    return commandExists('yarn') && fs.existsSync('yarn.lock');
  }


}
